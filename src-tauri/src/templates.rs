//! Template module for export functionality
//!
//! Contains script templates for Claude Code hooks integration.

/// Session ID generation function (shared across all hook scripts)
/// Generates a unique session identifier using hostname and PPID.
/// The receiving app (Windows) will map this ID to a human-readable name.
pub const SESSION_ID_FUNCTION: &str = r#"
# Generate unique session ID (hostname-ppid)
get_session_id() {
    echo "$(hostname)-${PPID}"
}
"#;

/// on-stop.sh template (mosquitto_pub version)
pub const ON_STOP_SH: &str = r#"#!/bin/bash
# Claude Code Stop Hook - Sends notification via MQTT
# Generated by Claude Code Notify

HOST="${CLAUDE_NOTIFY_HOST:-__HOST__}"
PORT="${CLAUDE_NOTIFY_PORT:-__PORT__}"
TOPIC="claude-code/events/stop"

# Get current working directory
CWD="${PWD}"

__SESSION_ID_FUNCTION__

# Get session ID for this Claude Code instance
SESSION_ID=$(get_session_id)

# Create JSON payload
PAYLOAD=$(cat <<EOF
{
  "event": "stop",
  "cwd": "${CWD}",
  "session_id": "${SESSION_ID}",
  "timestamp": "$(date -Iseconds)"
}
EOF
)

# Send MQTT message
mosquitto_pub -h "$HOST" -p "$PORT" -t "$TOPIC" -m "$PAYLOAD"
"#;

/// on-permission-request.sh template (mosquitto_pub version)
/// Handles permission/approval requests from Claude Code
pub const ON_PERMISSION_REQUEST_SH: &str = r#"#!/bin/bash
# Claude Code Permission Request Hook - Sends approval request notifications via MQTT
# Generated by Claude Code Notify

HOST="${CLAUDE_NOTIFY_HOST:-__HOST__}"
PORT="${CLAUDE_NOTIFY_PORT:-__PORT__}"
TOPIC="claude-code/events/permission-request"

# Get current working directory
CWD="${PWD}"

# Read the permission request content from stdin
REQUEST_CONTENT=$(cat)

__SESSION_ID_FUNCTION__

# Get session ID for this Claude Code instance
SESSION_ID=$(get_session_id)

# Create JSON payload
PAYLOAD=$(cat <<EOF
{
  "event": "permission-request",
  "cwd": "${CWD}",
  "session_id": "${SESSION_ID}",
  "content": ${REQUEST_CONTENT},
  "timestamp": "$(date -Iseconds)"
}
EOF
)

# Send MQTT message
mosquitto_pub -h "$HOST" -p "$PORT" -t "$TOPIC" -m "$PAYLOAD"
"#;

/// on-notification.sh template (mosquitto_pub version)
/// Handles elicitation dialogs from Claude Code (user input requests)
pub const ON_NOTIFICATION_SH: &str = r#"#!/bin/bash
# Claude Code Notification Hook - Sends elicitation dialog notifications via MQTT
# Generated by Claude Code Notify

HOST="${CLAUDE_NOTIFY_HOST:-__HOST__}"
PORT="${CLAUDE_NOTIFY_PORT:-__PORT__}"
TOPIC="claude-code/events/notification"

# Get current working directory
CWD="${PWD}"

# Read the notification content from stdin
NOTIFICATION_CONTENT=$(cat)

__SESSION_ID_FUNCTION__

# Get session ID for this Claude Code instance
SESSION_ID=$(get_session_id)

# Create JSON payload
PAYLOAD=$(cat <<EOF
{
  "event": "notification",
  "cwd": "${CWD}",
  "session_id": "${SESSION_ID}",
  "content": ${NOTIFICATION_CONTENT},
  "timestamp": "$(date -Iseconds)"
}
EOF
)

# Send MQTT message
mosquitto_pub -h "$HOST" -p "$PORT" -t "$TOPIC" -m "$PAYLOAD"
"#;

/// statusline.sh template (mosquitto_pub version)
/// Sends periodic status updates from Claude Code and outputs status text
pub const STATUSLINE_SH: &str = r#"#!/bin/bash
# Claude Code Statusline - Sends status updates via MQTT and outputs status
# Generated by Claude Code Notify

HOST="${CLAUDE_NOTIFY_HOST:-__HOST__}"
PORT="${CLAUDE_NOTIFY_PORT:-__PORT__}"

# Read the statusline JSON from stdin
INPUT=$(cat)

# Extract session_id from input
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // empty')
if [ -z "$SESSION_ID" ]; then
    SESSION_ID="default-session"
fi

TOPIC="claude-code/status/${SESSION_ID}"

# Extract status info for display
MODEL=$(echo "$INPUT" | jq -r '.model.display_name // "Claude"')
COST=$(echo "$INPUT" | jq -r '.cost.total_cost_usd // 0')
CONTEXT=$(echo "$INPUT" | jq -r '.context_window.used_percentage // 0')
LINES_ADDED=$(echo "$INPUT" | jq -r '.cost.total_lines_added // 0')
LINES_REMOVED=$(echo "$INPUT" | jq -r '.cost.total_lines_removed // 0')

# Create status payload for MQTT
PAYLOAD=$(cat <<EOF
{
  "session_id": "${SESSION_ID}",
  "cwd": "$(echo "$INPUT" | jq -r '.cwd // empty')",
  "status": {
    "state": "active",
    "context_percent": ${CONTEXT},
    "cost_usd": ${COST},
    "lines_added": ${LINES_ADDED},
    "lines_removed": ${LINES_REMOVED}
  },
  "timestamp": "$(date -Iseconds)"
}
EOF
)

# Send MQTT message in background (don't block statusline output)
mosquitto_pub -h "$HOST" -p "$PORT" -t "$TOPIC" -r -m "$PAYLOAD" 2>/dev/null &

# Output status text for Claude Code statusline display
printf "[%s] $%.4f | Ctx: %.0f%% | +%d/-%d" "$MODEL" "$COST" "$CONTEXT" "$LINES_ADDED" "$LINES_REMOVED"
"#;

/// Claude Code settings.json snippet template (hooks only, statusLine is optional)
pub const CLAUDE_SETTINGS_SNIPPET: &str = r#"{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "__SCRIPTS_DIR__/on-stop.sh"
          }
        ]
      }
    ],
    "PermissionRequest": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "__SCRIPTS_DIR__/on-permission-request.sh"
          }
        ]
      }
    ],
    "Notification": [
      {
        "matcher": "elicitation_dialog",
        "hooks": [
          {
            "type": "command",
            "command": "__SCRIPTS_DIR__/on-notification.sh"
          }
        ]
      }
    ]
  }
}

// Optional: Add statusLine for real-time status updates
// "statusLine": {
//   "type": "command",
//   "command": "__SCRIPTS_DIR__/statusline.sh"
// }
"#;

/// install.sh template - Automated installer for Claude Code side
pub const INSTALL_SH: &str = r#"#!/bin/bash
# Claude Code Notify - インストーラスクリプト
# Claude Code Notify により生成
#
# 使用方法: ./install.sh [--with-statusline]

set -e

# 設定
HOST="__HOST__"
PORT="__PORT__"
SCRIPTS_DIR="${HOME}/.claude-notify-scripts"
SETTINGS_FILE="${HOME}/.claude/settings.json"

# 出力用カラー
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}╔════════════════════════════════════════╗${NC}"
echo -e "${GREEN}║   Claude Code Notify インストーラ      ║${NC}"
echo -e "${GREEN}╚════════════════════════════════════════╝${NC}"
echo ""

# 引数の解析
WITH_STATUSLINE=false
for arg in "$@"; do
    case $arg in
        --with-statusline)
            WITH_STATUSLINE=true
            shift
            ;;
    esac
done

# 依存関係のチェック
echo -e "${YELLOW}依存関係を確認中...${NC}"

if ! command -v mosquitto_pub &> /dev/null; then
    echo -e "${RED}エラー: mosquitto_pub が見つかりません${NC}"
    echo "インストール: sudo apt install mosquitto-clients"
    exit 1
fi
echo -e "  ${GREEN}✓${NC} mosquitto_pub"

if ! command -v jq &> /dev/null; then
    echo -e "${RED}エラー: jq が見つかりません${NC}"
    echo "インストール: sudo apt install jq"
    exit 1
fi
echo -e "  ${GREEN}✓${NC} jq"

# スクリプトのソースディレクトリを取得
SCRIPT_SOURCE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# スクリプトディレクトリを作成
echo ""
echo -e "${YELLOW}スクリプトを ${SCRIPTS_DIR} にインストール中...${NC}"
mkdir -p "$SCRIPTS_DIR"

# スクリプトをコピー
cp "$SCRIPT_SOURCE_DIR/on-stop.sh" "$SCRIPTS_DIR/"
cp "$SCRIPT_SOURCE_DIR/on-permission-request.sh" "$SCRIPTS_DIR/"
cp "$SCRIPT_SOURCE_DIR/on-notification.sh" "$SCRIPTS_DIR/"
if [ "$WITH_STATUSLINE" = true ]; then
    cp "$SCRIPT_SOURCE_DIR/statusline.sh" "$SCRIPTS_DIR/"
fi

# 実行権限を設定
chmod +x "$SCRIPTS_DIR"/*.sh
echo -e "  ${GREEN}✓${NC} スクリプトをインストールしました"

# settings.json を更新
echo ""
echo -e "${YELLOW}Claude Code の設定を更新中...${NC}"

mkdir -p "$(dirname "$SETTINGS_FILE")"

if [ -f "$SETTINGS_FILE" ]; then
    # 既存の設定をバックアップ
    cp "$SETTINGS_FILE" "${SETTINGS_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
    echo -e "  ${GREEN}✓${NC} 既存の設定をバックアップしました"

    EXISTING_SETTINGS=$(cat "$SETTINGS_FILE")
else
    EXISTING_SETTINGS="{}"
fi

# フック設定を作成
HOOKS_CONFIG=$(cat <<EOF
{
  "Stop": [
    {
      "matcher": "",
      "hooks": [
        {
          "type": "command",
          "command": "${SCRIPTS_DIR}/on-stop.sh"
        }
      ]
    }
  ],
  "PermissionRequest": [
    {
      "matcher": "",
      "hooks": [
        {
          "type": "command",
          "command": "${SCRIPTS_DIR}/on-permission-request.sh"
        }
      ]
    }
  ],
  "Notification": [
    {
      "matcher": "elicitation_dialog",
      "hooks": [
        {
          "type": "command",
          "command": "${SCRIPTS_DIR}/on-notification.sh"
        }
      ]
    }
  ]
}
EOF
)

# フックをインテリジェントにマージする関数
# - ユーザー定義のフック（~/.claude-notify-scripts/ 以外）を保持
# - このアプリのフックを置換/追加
merge_hook_array() {
    local existing="$1"
    local new_hook="$2"
    local scripts_dir="$3"

    # 既存からこのアプリのフックを除外し、新しいフックを追加
    echo "$existing" | jq --argjson new "$new_hook" --arg dir "$scripts_dir" '
        # このスクリプトディレクトリ以外のフックのみを保持
        [.[] | select(.hooks | all(.command | contains($dir) | not))]
        # 新しいフックを追加
        + [$new]
    '
}

# 個別のフック設定を作成
STOP_HOOK=$(cat <<EOF
{
  "matcher": "",
  "hooks": [
    {
      "type": "command",
      "command": "${SCRIPTS_DIR}/on-stop.sh"
    }
  ]
}
EOF
)

NOTIFICATION_HOOK=$(cat <<EOF
{
  "matcher": "elicitation_dialog",
  "hooks": [
    {
      "type": "command",
      "command": "${SCRIPTS_DIR}/on-notification.sh"
    }
  ]
}
EOF
)

PERMISSION_HOOK=$(cat <<EOF
{
  "matcher": "",
  "hooks": [
    {
      "type": "command",
      "command": "${SCRIPTS_DIR}/on-permission-request.sh"
    }
  ]
}
EOF
)

# 既存のフックまたは空の配列を取得
EXISTING_STOP=$(echo "$EXISTING_SETTINGS" | jq '.hooks.Stop // []')
EXISTING_NOTIFICATION=$(echo "$EXISTING_SETTINGS" | jq '.hooks.Notification // []')
EXISTING_PERMISSION=$(echo "$EXISTING_SETTINGS" | jq '.hooks.PermissionRequest // []')

# 各フックタイプをマージ（ユーザーフックは保持、アプリフックは置換）
NEW_STOP=$(merge_hook_array "$EXISTING_STOP" "$STOP_HOOK" "$SCRIPTS_DIR")
NEW_NOTIFICATION=$(merge_hook_array "$EXISTING_NOTIFICATION" "$NOTIFICATION_HOOK" "$SCRIPTS_DIR")
NEW_PERMISSION=$(merge_hook_array "$EXISTING_PERMISSION" "$PERMISSION_HOOK" "$SCRIPTS_DIR")

# 最終的なフックオブジェクトを構築
MERGED_SETTINGS=$(echo "$EXISTING_SETTINGS" | jq \
    --argjson stop "$NEW_STOP" \
    --argjson notif "$NEW_NOTIFICATION" \
    --argjson perm "$NEW_PERMISSION" '
    .hooks = (.hooks // {}) + {
        "Stop": $stop,
        "Notification": $notif,
        "PermissionRequest": $perm
    }
')

# statusline が要求された場合は追加
if [ "$WITH_STATUSLINE" = true ]; then
    MERGED_SETTINGS=$(echo "$MERGED_SETTINGS" | jq --arg cmd "${SCRIPTS_DIR}/statusline.sh" '
      .statusLine = {
        "type": "command",
        "command": $cmd
      }
    ')
    echo -e "  ${GREEN}✓${NC} statusline を設定しました"
fi

# マージした設定を書き込み
echo "$MERGED_SETTINGS" | jq '.' > "$SETTINGS_FILE"
echo -e "  ${GREEN}✓${NC} 設定を更新しました"

# 環境変数のヒント
echo ""
echo -e "${YELLOW}環境変数（オプション）:${NC}"
echo "  export CLAUDE_NOTIFY_HOST=\"$HOST\""
echo "  export CLAUDE_NOTIFY_PORT=\"$PORT\""
echo ""

# 接続テスト
echo -e "${YELLOW}Windows への接続をテスト中...${NC}"
if mosquitto_pub -h "$HOST" -p "$PORT" -t "claude-code/test" -m "install-test" 2>/dev/null; then
    echo -e "  ${GREEN}✓${NC} 接続成功"
else
    echo -e "  ${RED}✗${NC} 接続失敗 - ファイアウォール設定を確認してください"
fi

echo ""
echo -e "${GREEN}════════════════════════════════════════${NC}"
echo -e "${GREEN}インストール完了！${NC}"
echo ""
echo "インストールされたフック:"
echo "  - Stop（タスク完了通知）"
echo "  - PermissionRequest（承認依頼通知）"
echo "  - Notification（入力要求通知 - elicitation_dialog のみ）"
if [ "$WITH_STATUSLINE" = true ]; then
    echo "  - statusLine（リアルタイムステータス）"
fi
echo ""
echo "変更を反映するには Claude Code を再起動してください。"
echo -e "${GREEN}════════════════════════════════════════${NC}"
"#;

/// README.txt template for setup instructions
pub const README_TEMPLATE: &str = r#"Claude Code Notify セットアップガイド
========================================

【クイックスタート】自動インストール
====================================

1. 必要なソフトウェアをインストール:
   sudo apt install mosquitto-clients jq

2. ZIPを展開:
   unzip claude-code-notify-config.zip -d ~/claude-notify-setup
   cd ~/claude-notify-setup

3. インストーラを実行:
   chmod +x install.sh
   ./install.sh

   ※ statusline機能も使う場合:
   ./install.sh --with-statusline

4. Claude Code を再起動


【手動セットアップ】
====================================

1. 必要なソフトウェア
-------------------
- mosquitto-clients (mosquitto_pub コマンド)
  インストール: sudo apt install mosquitto-clients
- jq (JSON処理用)
  インストール: sudo apt install jq

2. スクリプトの配置
-------------------
1. すべてのスクリプトを任意の場所にコピー
   推奨: ~/.claude-notify-scripts/

2. 実行権限を付与:
   chmod +x ~/.claude-notify-scripts/*.sh

含まれるスクリプト:
- on-stop.sh              : タスク完了時の通知 (Stop hook)
- on-permission-request.sh: 承認依頼通知 (PermissionRequest hook)
- on-notification.sh      : 入力要求通知 (Notification hook - elicitation_dialog)
- statusline.sh           : ステータスライン更新 (オプション)

3. Claude Code の設定
-------------------
1. ~/.claude/settings.json を開く (なければ作成)

2. hooks-settings-snippet.json の内容を参考に設定を追加

3. __SCRIPTS_DIR__ を実際のパスに置換
   例: /home/username/.claude-notify-scripts

利用可能なフック:
- Stop             : タスク完了時
- PermissionRequest: 権限ダイアログ表示時（承認依頼）
- Notification     : elicitation_dialog（ユーザー入力要求）のみ

※ statusLine は hooks とは別の設定項目でオプションです。
  既存のstatusline設定がある場合は、そのまま使用できます。

4. 接続情報
-------------------
Windows PC の IP アドレス: __HOST__
MQTT ポート: __PORT__

5. テスト方法
-------------------
手動でスクリプトを実行して通知が届くか確認:
  ~/.claude-notify-scripts/on-stop.sh

または mosquitto_pub で直接テスト:
  mosquitto_pub -h __HOST__ -p __PORT__ -t "claude-code/events/stop" -m '{"event":"stop","cwd":"/test"}'

承認依頼通知のテスト:
  echo '{"tool_name":"Bash","tool_input":{"command":"npm install"}}' | ~/.claude-notify-scripts/on-permission-request.sh

6. トラブルシューティング
-------------------
- ファイアウォールで TCP __PORT__ を許可しているか確認
- Windows側のアプリが起動しているか確認
- mosquitto_pub がインストールされているか確認:
    which mosquitto_pub
- ネットワーク接続を確認:
    ping __HOST__
"#;

// =============================================================================
// Windows (PowerShell) Templates
// =============================================================================

/// Session ID generation function for PowerShell
/// Generates a unique session identifier using hostname and PID.
/// The receiving app (Windows) will map this ID to a human-readable name.
pub const SESSION_ID_FUNCTION_PS1: &str = r#"
# Generate unique session ID (hostname-pid)
function Get-SessionId {
    return "$env:COMPUTERNAME-$PID"
}
"#;

/// on-stop.ps1 template for Windows
pub const ON_STOP_PS1: &str = r#"#Requires -Version 5.1
# Claude Code Stop Hook - Sends notification via MQTT
# Generated by Claude Code Notify

param()

$ErrorActionPreference = "SilentlyContinue"

# Ensure UTF-8 encoding for pipe output
$OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

$NotifyHost = if ($env:CLAUDE_NOTIFY_HOST) { $env:CLAUDE_NOTIFY_HOST } else { "__HOST__" }
$NotifyPort = if ($env:CLAUDE_NOTIFY_PORT) { $env:CLAUDE_NOTIFY_PORT } else { "__PORT__" }
$Topic = "claude-code/events/stop"
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path

__SESSION_ID_FUNCTION__

$SessionId = Get-SessionId
$Cwd = (Get-Location).Path
$Timestamp = Get-Date -Format "o"

$PayloadObj = @{
    event = "stop"
    cwd = $Cwd
    session_id = $SessionId
    timestamp = $Timestamp
}
$Payload = $PayloadObj | ConvertTo-Json -Compress

# Use stdin to avoid escaping issues
$Payload | & "$ScriptDir\mqtt-publish.exe" -h $NotifyHost -p $NotifyPort -t $Topic --stdin
"#;

/// on-permission-request.ps1 template for Windows
pub const ON_PERMISSION_REQUEST_PS1: &str = r#"#Requires -Version 5.1
# Claude Code Permission Request Hook - Sends approval request notifications via MQTT
# Generated by Claude Code Notify

param()

$ErrorActionPreference = "SilentlyContinue"

# Ensure UTF-8 encoding for pipe output
$OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

$NotifyHost = if ($env:CLAUDE_NOTIFY_HOST) { $env:CLAUDE_NOTIFY_HOST } else { "__HOST__" }
$NotifyPort = if ($env:CLAUDE_NOTIFY_PORT) { $env:CLAUDE_NOTIFY_PORT } else { "__PORT__" }
$Topic = "claude-code/events/permission-request"
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path

# Read request content from stdin with proper UTF-8 handling
$reader = New-Object System.IO.StreamReader([Console]::OpenStandardInput(), [System.Text.Encoding]::UTF8)
$RequestContent = $reader.ReadToEnd()
$reader.Close()

__SESSION_ID_FUNCTION__

$SessionId = Get-SessionId
$Cwd = (Get-Location).Path
$Timestamp = Get-Date -Format "o"

# Parse the request content
try {
    $ContentObj = $RequestContent | ConvertFrom-Json
} catch {
    $ContentObj = @{ raw = $RequestContent }
}

$PayloadObj = @{
    event = "permission-request"
    cwd = $Cwd
    session_id = $SessionId
    content = $ContentObj
    timestamp = $Timestamp
}
$Payload = $PayloadObj | ConvertTo-Json -Depth 10 -Compress

# Use stdin to avoid escaping issues
$Payload | & "$ScriptDir\mqtt-publish.exe" -h $NotifyHost -p $NotifyPort -t $Topic --stdin
"#;

/// on-notification.ps1 template for Windows
pub const ON_NOTIFICATION_PS1: &str = r#"#Requires -Version 5.1
# Claude Code Notification Hook - Sends elicitation dialog notifications via MQTT
# Generated by Claude Code Notify

param()

$ErrorActionPreference = "SilentlyContinue"

# Ensure UTF-8 encoding for pipe output
$OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

$NotifyHost = if ($env:CLAUDE_NOTIFY_HOST) { $env:CLAUDE_NOTIFY_HOST } else { "__HOST__" }
$NotifyPort = if ($env:CLAUDE_NOTIFY_PORT) { $env:CLAUDE_NOTIFY_PORT } else { "__PORT__" }
$Topic = "claude-code/events/notification"
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path

# Read notification content from stdin with proper UTF-8 handling
$reader = New-Object System.IO.StreamReader([Console]::OpenStandardInput(), [System.Text.Encoding]::UTF8)
$NotificationContent = $reader.ReadToEnd()
$reader.Close()

__SESSION_ID_FUNCTION__

$SessionId = Get-SessionId
$Cwd = (Get-Location).Path
$Timestamp = Get-Date -Format "o"

# Parse the notification content
try {
    $ContentObj = $NotificationContent | ConvertFrom-Json
} catch {
    $ContentObj = @{ raw = $NotificationContent }
}

$PayloadObj = @{
    event = "notification"
    cwd = $Cwd
    session_id = $SessionId
    content = $ContentObj
    timestamp = $Timestamp
}
$Payload = $PayloadObj | ConvertTo-Json -Depth 10 -Compress

# Use stdin to avoid escaping issues
$Payload | & "$ScriptDir\mqtt-publish.exe" -h $NotifyHost -p $NotifyPort -t $Topic --stdin
"#;

/// statusline.ps1 template for Windows
pub const STATUSLINE_PS1: &str = r#"#Requires -Version 5.1
# Claude Code Statusline - Sends status updates via MQTT and outputs status
# Generated by Claude Code Notify

param()

$ErrorActionPreference = "SilentlyContinue"

# Ensure UTF-8 encoding for pipe output
$OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

$NotifyHost = if ($env:CLAUDE_NOTIFY_HOST) { $env:CLAUDE_NOTIFY_HOST } else { "__HOST__" }
$NotifyPort = if ($env:CLAUDE_NOTIFY_PORT) { $env:CLAUDE_NOTIFY_PORT } else { "__PORT__" }
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path

# Read the statusline JSON from stdin with proper UTF-8 handling
$reader = New-Object System.IO.StreamReader([Console]::OpenStandardInput(), [System.Text.Encoding]::UTF8)
$InputJson = $reader.ReadToEnd()
$reader.Close()

try {
    $Input_ = $InputJson | ConvertFrom-Json
} catch {
    Write-Host "[Claude] Status unavailable"
    exit 0
}

# Extract session_id from input
$SessionId = if ($Input_.session_id) { $Input_.session_id } else { "default-session" }
$Topic = "claude-code/status/$SessionId"

# Extract status info for display
$Model = if ($Input_.model.display_name) { $Input_.model.display_name } else { "Claude" }
$Cost = if ($Input_.cost.total_cost_usd) { $Input_.cost.total_cost_usd } else { 0 }
$Context = if ($Input_.context_window.used_percentage) { $Input_.context_window.used_percentage } else { 0 }
$LinesAdded = if ($Input_.cost.total_lines_added) { $Input_.cost.total_lines_added } else { 0 }
$LinesRemoved = if ($Input_.cost.total_lines_removed) { $Input_.cost.total_lines_removed } else { 0 }
$Cwd = if ($Input_.cwd) { $Input_.cwd } else { "" }

# Create status payload for MQTT
$PayloadObj = @{
    session_id = $SessionId
    cwd = $Cwd
    status = @{
        state = "active"
        context_percent = $Context
        cost_usd = $Cost
        lines_added = $LinesAdded
        lines_removed = $LinesRemoved
    }
    timestamp = (Get-Date -Format "o")
}
$Payload = $PayloadObj | ConvertTo-Json -Depth 10 -Compress

# Send MQTT message in background using stdin
Start-Job -ScriptBlock {
    param($exe, $h, $p, $t, $payload)
    $payload | & $exe -h $h -p $p -t $t -r --stdin
} -ArgumentList "$ScriptDir\mqtt-publish.exe", $NotifyHost, $NotifyPort, $Topic, $Payload | Out-Null

# Output status text for Claude Code statusline display
$CostFormatted = $Cost.ToString("F4")
$ContextFormatted = [math]::Round($Context, 0)
Write-Host "[$Model] `$$CostFormatted | Ctx: $ContextFormatted% | +$LinesAdded/-$LinesRemoved" -NoNewline
"#;

/// install.ps1 template - Automated installer for Windows
pub const INSTALL_PS1: &str = r#"#Requires -Version 5.1
# Claude Code Notify - Windows Installer Script
# Generated by Claude Code Notify
#
# Usage: .\install.ps1 [-WithStatusline]

param(
    [switch]$WithStatusline
)

$ErrorActionPreference = "Stop"

# Configuration
$NotifyHost = "__HOST__"
$NotifyPort = "__PORT__"
$ScriptsDir = "$env:USERPROFILE\.claude-notify-scripts"
$SettingsFile = "$env:USERPROFILE\.claude\settings.json"

Write-Host ""
Write-Host "========================================" -ForegroundColor Green
Write-Host "  Claude Code Notify Installer" -ForegroundColor Green
Write-Host "  Windows Native Edition" -ForegroundColor Green
Write-Host "========================================" -ForegroundColor Green
Write-Host ""

# Get script source directory
$ScriptSourceDir = Split-Path -Parent $MyInvocation.MyCommand.Path

# Create scripts directory
Write-Host "Installing scripts to $ScriptsDir..." -ForegroundColor Yellow
if (-not (Test-Path $ScriptsDir)) {
    New-Item -ItemType Directory -Path $ScriptsDir -Force | Out-Null
}

# Copy files
Copy-Item "$ScriptSourceDir\mqtt-publish.exe" "$ScriptsDir\" -Force
Copy-Item "$ScriptSourceDir\on-stop.ps1" "$ScriptsDir\" -Force
Copy-Item "$ScriptSourceDir\on-permission-request.ps1" "$ScriptsDir\" -Force
Copy-Item "$ScriptSourceDir\on-notification.ps1" "$ScriptsDir\" -Force

if ($WithStatusline) {
    Copy-Item "$ScriptSourceDir\statusline.ps1" "$ScriptsDir\" -Force
}

Write-Host "  [OK] Scripts installed" -ForegroundColor Green

# Update Claude Code settings
Write-Host ""
Write-Host "Updating Claude Code settings..." -ForegroundColor Yellow

$ClaudeDir = Split-Path -Parent $SettingsFile
if (-not (Test-Path $ClaudeDir)) {
    New-Item -ItemType Directory -Path $ClaudeDir -Force | Out-Null
}

$ExistingSettings = @{}
if (Test-Path $SettingsFile) {
    # Backup existing settings
    $BackupPath = "$SettingsFile.backup.$(Get-Date -Format 'yyyyMMdd_HHmmss')"
    Copy-Item $SettingsFile $BackupPath
    Write-Host "  [OK] Backed up existing settings to $BackupPath" -ForegroundColor Green

    try {
        $ExistingSettings = Get-Content $SettingsFile -Raw | ConvertFrom-Json -AsHashtable
    } catch {
        $ExistingSettings = @{}
    }
}

# Escape backslashes for JSON
$ScriptsDirEscaped = $ScriptsDir.Replace('\', '\\')

# Prepare hooks configuration
$StopCommand = "powershell.exe -ExecutionPolicy Bypass -File `"$ScriptsDir\on-stop.ps1`""
$PermissionCommand = "powershell.exe -ExecutionPolicy Bypass -File `"$ScriptsDir\on-permission-request.ps1`""
$NotificationCommand = "powershell.exe -ExecutionPolicy Bypass -File `"$ScriptsDir\on-notification.ps1`""

# Build hooks structure
if (-not $ExistingSettings.ContainsKey("hooks")) {
    $ExistingSettings["hooks"] = @{}
}

# Helper function to filter out our hooks and add new one
function Update-HookArray {
    param($existing, $newHook, $scriptsDir)

    $filtered = @()
    if ($existing) {
        foreach ($hook in $existing) {
            $isOurs = $false
            if ($hook.hooks) {
                foreach ($h in $hook.hooks) {
                    if ($h.command -and $h.command -like "*\.claude-notify-scripts\*") {
                        $isOurs = $true
                        break
                    }
                }
            }
            if (-not $isOurs) {
                $filtered += $hook
            }
        }
    }
    return @($filtered) + @($newHook)
}

# Stop hook
$StopHook = @{
    matcher = ""
    hooks = @(
        @{
            type = "command"
            command = $StopCommand
        }
    )
}
$ExistingSettings["hooks"]["Stop"] = Update-HookArray $ExistingSettings["hooks"]["Stop"] $StopHook $ScriptsDir

# PermissionRequest hook
$PermissionHook = @{
    matcher = ""
    hooks = @(
        @{
            type = "command"
            command = $PermissionCommand
        }
    )
}
$ExistingSettings["hooks"]["PermissionRequest"] = Update-HookArray $ExistingSettings["hooks"]["PermissionRequest"] $PermissionHook $ScriptsDir

# Notification hook
$NotificationHook = @{
    matcher = "elicitation_dialog"
    hooks = @(
        @{
            type = "command"
            command = $NotificationCommand
        }
    )
}
$ExistingSettings["hooks"]["Notification"] = Update-HookArray $ExistingSettings["hooks"]["Notification"] $NotificationHook $ScriptsDir

# Add statusline if requested
if ($WithStatusline) {
    $StatuslineCommand = "powershell.exe -ExecutionPolicy Bypass -File `"$ScriptsDir\statusline.ps1`""
    $ExistingSettings["statusLine"] = @{
        type = "command"
        command = $StatuslineCommand
    }
    Write-Host "  [OK] Statusline configured" -ForegroundColor Green
}

# Write settings
$ExistingSettings | ConvertTo-Json -Depth 10 | Set-Content $SettingsFile -Encoding UTF8
Write-Host "  [OK] Settings updated" -ForegroundColor Green

# Environment variables hint
Write-Host ""
Write-Host "Environment variables (optional):" -ForegroundColor Yellow
Write-Host "  `$env:CLAUDE_NOTIFY_HOST = `"$NotifyHost`""
Write-Host "  `$env:CLAUDE_NOTIFY_PORT = `"$NotifyPort`""

# Connection test
Write-Host ""
Write-Host "Testing connection to Windows PC..." -ForegroundColor Yellow
try {
    $result = & "$ScriptsDir\mqtt-publish.exe" -h $NotifyHost -p $NotifyPort -t "claude-code/test" -m "install-test" 2>&1
    if ($LASTEXITCODE -eq 0) {
        Write-Host "  [OK] Connection successful" -ForegroundColor Green
    } else {
        Write-Host "  [FAIL] Connection failed - check firewall settings" -ForegroundColor Red
    }
} catch {
    Write-Host "  [FAIL] Connection failed - $($_.Exception.Message)" -ForegroundColor Red
}

Write-Host ""
Write-Host "========================================" -ForegroundColor Green
Write-Host "Installation complete!" -ForegroundColor Green
Write-Host ""
Write-Host "Installed hooks:"
Write-Host "  - Stop (task completion notification)"
Write-Host "  - PermissionRequest (approval request notification)"
Write-Host "  - Notification (input request notification)"
if ($WithStatusline) {
    Write-Host "  - statusLine (real-time status)"
}
Write-Host ""
Write-Host "Please restart Claude Code to apply changes."
Write-Host "========================================" -ForegroundColor Green
"#;

/// Claude Code settings.json snippet template for Windows
pub const CLAUDE_SETTINGS_SNIPPET_WINDOWS: &str = r#"{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "powershell.exe -ExecutionPolicy Bypass -File \"__SCRIPTS_DIR__\\on-stop.ps1\""
          }
        ]
      }
    ],
    "PermissionRequest": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "powershell.exe -ExecutionPolicy Bypass -File \"__SCRIPTS_DIR__\\on-permission-request.ps1\""
          }
        ]
      }
    ],
    "Notification": [
      {
        "matcher": "elicitation_dialog",
        "hooks": [
          {
            "type": "command",
            "command": "powershell.exe -ExecutionPolicy Bypass -File \"__SCRIPTS_DIR__\\on-notification.ps1\""
          }
        ]
      }
    ]
  }
}
"#;

/// README.txt template for Windows setup instructions
pub const README_WINDOWS_TEMPLATE: &str = r#"Claude Code Notify セットアップガイド (Windows)
================================================

【クイックスタート】自動インストール
====================================

1. ZIPを展開:
   - 任意のフォルダに展開してください

2. PowerShellでインストーラを実行:
   - エクスプローラーで展開したフォルダを開く
   - アドレスバーに「powershell」と入力してEnter
   - 以下のコマンドを実行:

   .\install.ps1

   ※ statusline機能も使う場合:
   .\install.ps1 -WithStatusline

3. Claude Code を再起動


【手動セットアップ】
====================================

1. 含まれるファイル
-------------------
- mqtt-publish.exe        : MQTT送信ツール（追加インストール不要）
- on-stop.ps1             : タスク完了時の通知 (Stop hook)
- on-permission-request.ps1: 承認依頼通知 (PermissionRequest hook)
- on-notification.ps1     : 入力要求通知 (Notification hook)
- statusline.ps1          : ステータスライン更新 (オプション)

2. ファイルの配置
-------------------
1. すべてのファイルを以下にコピー:
   %USERPROFILE%\.claude-notify-scripts\

2. PowerShellでコピー:
   New-Item -ItemType Directory -Path "$env:USERPROFILE\.claude-notify-scripts" -Force
   Copy-Item *.exe,*.ps1 "$env:USERPROFILE\.claude-notify-scripts\"

3. Claude Code の設定
-------------------
1. %USERPROFILE%\.claude\settings.json を開く (なければ作成)

2. hooks-settings-snippet.json の内容を参考に設定を追加

3. __SCRIPTS_DIR__ を実際のパスに置換
   例: C:\Users\YourName\.claude-notify-scripts

4. 接続情報
-------------------
Windows PC の IP アドレス: __HOST__
MQTT ポート: __PORT__

5. テスト方法
-------------------
PowerShellで手動でスクリプトを実行して通知が届くか確認:

  & "$env:USERPROFILE\.claude-notify-scripts\on-stop.ps1"

または mqtt-publish.exe で直接テスト:

  & "$env:USERPROFILE\.claude-notify-scripts\mqtt-publish.exe" -h __HOST__ -p __PORT__ -t "claude-code/events/stop" -m '{"event":"stop","cwd":"C:\\test"}'

6. トラブルシューティング
-------------------
- ファイアウォールで TCP __PORT__ を許可しているか確認
- Windows側のアプリが起動しているか確認
- PowerShell実行ポリシーを確認:
    Get-ExecutionPolicy
  必要に応じて:
    Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
- ネットワーク接続を確認:
    Test-NetConnection -ComputerName __HOST__ -Port __PORT__
"#;
